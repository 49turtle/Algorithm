# PRGS_연습문제 리코쳇 로봇


출처: https://school.programmers.co.kr/learn/courses/30/lessons/169199



<br>

## 문제 설명

<br>


리코쳇 로봇이라는 보드게임이 있습니다.

이 보드게임은 격자모양 게임판 위에서 말을 움직이는 게임으로, 시작 위치에서 목표 위치까지 최소 몇 번만에 도달할 수 있는지 말하는 게임입니다.

이 게임에서 말의 움직임은 상, 하, 좌, 우 4방향 중 하나를 선택해서 게임판 위의 장애물이나 맨 끝에 부딪힐 때까지 미끄러져 이동하는 것을 한 번의 이동으로 칩니다.

다음은 보드게임판을 나타낸 예시입니다.


```
...D..R
.D.G...
....D.D
D....D.
..D....
```


여기서 "."은 빈 공간을, "R"은 로봇의 처음 위치를, "D"는 장애물의 위치를, "G"는 목표지점을 나타냅니다.
위 예시에서는 "R" 위치에서 아래, 왼쪽, 위, 왼쪽, 아래, 오른쪽, 위 순서로 움직이면 7번 만에 "G" 위치에 멈춰 설 수 있으며, 이것이 최소 움직임 중 하나입니다.

게임판의 상태를 나타내는 문자열 배열 `board`가 주어졌을 때, 말이 목표위치에 도달하는데 최소 몇 번 이동해야 하는지 return 하는 solution함수를 완성하세요. 만약 목표위치에 도달할 수 없다면 -1을 return 해주세요.



<br>

## 제한사항

<br>



- 3 ≤ `board`의 길이 ≤ 100
  - 3 ≤ `board`의 원소의 길이 ≤ 100
  - `board`의 원소의 길이는 모두 동일합니다.
  - 문자열은 ".", "D", "R", "G"로만 구성되어 있으며 각각 빈 공간, 장애물, 로봇의 처음 위치, 목표 지점을 나타냅니다.
  - "R"과 "G"는 한 번씩 등장합니다.


<br>

## 입출력 예시

<br>

| board	| result |
| - | - |
| ["...D..R", ".D.G...", "....D.D", "D....D.", "..D...."] | 7 |
| [".D.R", "....", ".G..", "...D"] | -1 |

<br>

## 풀이

<br>

코딩테스트 대비를 위해 IDE 없이 프로그래머스의 Lv.2 ~ Lv.3 문제 위주로 진행해보려고 했습니다.

기본적으로 맵을 탐색하는 탐색에 관한 문제이므로, DFS 또는 BFS를 적절히 구현하면 될 것이라 생각합니다.

**풀이 순서**

1. 입력으로 주어지는 것이 `String[]` 배열이므로 이를 평소에 내가 활용하던 `int[][]` 2차원 배열 형태로 바꾸고 싶었습니다. 따라서 문자열 배열을 순회하면서 charAt() 메소드로 정수형 2차원 배열인 `map`에 내가 임의로 지정한 수로 빈 공간/장애물/시작/종료 지점을 설정했습니다.
2. DFS의 depth를 이용해 최단 거리를 계산하고자 했습니다. 등장 가능한 map의 최대 크기는 `100x100` 이므로 고민하지 않고, dfs 탐색을 진행해도 될 것이라 생각했습니다.
3. DFS 내에서 맵 밖 또는 장애물에 부딪힐 때까지는 증가하는 구문을 while문으로 구성했고, 따로 선언한 dist 2차원 배열을 통해 최단 거리를 저장하고 갱신하는 방식으로 문제를 해결했습니다.

